; -*- lexical-binding: t -*-

(require 'func-utils)

(ert-deftest compose ()
  (should (= 19 (funcall (compose (partial #'+ 3)
                                  (partial #'* 4)
                                  (partial #'- 10))
                         3 2 1))))

(ert-deftest partial ()
  (should (= (- 9 3 2)
             (funcall (partial #'-)
                      9 3 2)
             (funcall (partial #'- 9)
                      3 2)
             (funcall (partial #'- 9 3)
                      2)
             (funcall (partial #'- 9 3 2)))))

(ert-deftest mcompose ()
  (should (= -1 (eval '(funcall (mcompose (+ - 2)) 3))))
  (should (= 4 (eval '(funcall (mcompose (+ - 2)) 3 1))))
  (should (let ((sym (gensym))) (eq sym (eval `(funcall (mcompose (quote ,sym)) 9)))))
  (should (= 7 (funcall (mcompose (+ 1 (lambda (x) (* x 3)))) 2)))
  (= 6 (funcall (mcompose (/ (1) (2))) 18 3 2)))

(ert-deftest arglist->args ()
  (should (equal '(a b c) (arglist->args '(a b c))))
  (should (equal '(d e) (arglist->args '(&optional d e))))
  (should (equal '(f) (arglist->args '(&rest f))))
  (should (equal '(a b c d e) (arglist->args '(a b c &optional d e))))
  (should (equal '(a b c f) (arglist->args '(a b c &rest f))))
  (should (equal '(d e f) (arglist->args '(&optional d e &rest f))))
  (should (equal '(a b c d e f) (arglist->args '(a b c &optional d e &rest f))))
  (let ((debug-on-error nil))
    (should-error (arglist->args '(&rest f g)) :type 'cl-assertion-failed))
  (should (equal '(f) (arglist->args '(&rest f) t)))
  (should (equal '(a b c nil) (arglist->args '(a b c) t))))

(defun recur--test-f-loop (num)
  (let ((count 0))
    (while (> num 0)
      (setf num (/ num 2)
            count (1+ count)))
    count))

(defun recur--test-f (num &optional count)
  (unless count (setf count 0))
  (if (> num 0)
      (recur--test-f (/ num 2) (1+ count))
    count))

(defrecur recur--test-f-rec-stack (num &optional count)
  (unless count (setf count 0))
  (if (> num 0)
      (recur--test-f-rec-stack (/ num 2) (1+ count))
    count))

(defrecur recur--test-f-rec (num &optional count)
  (unless count (setf count 0))
  (if (> num 0)
      (recur #'recur--test-f-rec (/ num 2) (1+ count))
    count))

(ert-deftest recur ()
  (should (= 3 (funcall (recur-lambda (a b) (+ a b)) 1 2)))
  (letrec ((f (recur-lambda (num &optional count)
                            (unless count (setf count 0))
                            (if (> num 0)
                                (funcall f (/ num 2) (1+ count))
                              count)))
           (f-rec-stack (recur-lambda (num &optional count)
                                      (unless count (setf count 0))
                                      (if (> num 0)
                                          (funcall f-rec-stack (/ num 2) (1+ count))
                                        count)))
           (f-rec (recur-lambda (num &optional count)
                                (unless count (setf count 0))
                                (if (> num 0)
                                    (recur f-rec (/ num 2) (1+ count))
                                  count)))
           (small-x 999)
           (large-x 99999999999999999999999999999999999999999999))
    (should (= 10
               (funcall f small-x) (funcall f-rec-stack small-x) (funcall f-rec small-x)
               (recur--test-f small-x) (recur--test-f-rec-stack small-x) (recur--test-f-rec small-x)
               (recur--test-f-loop small-x)))
    (should-error (funcall f large-x) :type 'error)
    (should-error (recur--test-f-rec-stack large-x) :type 'error)
    (should (= 147 (funcall f-rec large-x) (recur--test-f-rec large-x) (recur--test-f-loop large-x)))))

(ert-deftest gurd-map ()
  (should (let ((list (list 1 2 3 4))
                (vec (vector 2 3 4 5))
                (str (string ?a ?b ?c ?d))
                (bool-vector (bool-vector t t nil t)))
            (equal (gurd-map 'list list vec str bool-vector)
                   '((1 2 97 t) (2 3 98 t) (3 4 99 nil) (4 5 100 t))))))

(provide 'test-func-utils)
